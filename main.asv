%% CFD: 2D Steady Convection–Diffusion
clear; clc; close all;

% Parameters
rho = 1;          % kg/m^3
cp = 10;          % J/(K*kg)
k = 0.12;         % W/(m*K)
nu = 1e-2;        % m^2/s
Gamma = k / cp;

H = 1; L = 10;
nx = 50; ny = 5;

dx = L / (nx - 1);
dy = H / (ny - 1);

Pe = 16.5;
umean = Pe * Gamma / (2 * H * rho);
Re = 2 * H * umean / nu;

fprintf('umean = %.4f m/s, Re = %.2f\n', umean, Re);

% Velocity profile
x = linspace(0, L, nx);
y = linspace(0, H, ny);
umax = 3/2 * umean;
ux = umax * (1 - (2*y/H - 1).^2);

% Boundary conditions
Tin = 50;  
Twall = 100;

% Build system matrix and RHS 
[A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, "UD");

%% Problem 11: Solve linear system
T = A \ b;

% Plot
Tfield = reshape(T, [nx, ny])';
x = linspace(0, L, nx);

figure;
contourf(x, y, Tfield, 30, 'LineColor','none');
colorbar;
xlabel('x [m]');
ylabel('y [m]');
title('Temperature Field T(x,y)');


%% Problem 12: Suitable plots
figure;
subplot(2,2,1);
plot(y, Tfield(:,1),'LineWidth',1.5);
xlabel('y [m]'); ylabel('T [°C]');
title('Inlet (x=0)');
grid on;

subplot(2,2,2);
plot(y, Tfield(:,end),'LineWidth',1.5);
xlabel('y [m]'); ylabel('T [°C]');
title('Outlet (x=L)');
grid on;

subplot(2,2,3);
plot(x, Tfield(1,:),'LineWidth',1.5);
xlabel('x [m]'); ylabel('T [°C]');
title('Lower wall (y=0)');
grid on;

subplot(2,2,4);
plot(x, Tfield(end,:),'LineWidth',1.5);
xlabel('x [m]'); ylabel('T [°C]');
title('Upper wall (y=H)');
grid on;

%% Problem 13: Temperature plots
% (a) Outlet temperature profile
To = Tfield(:,end);
figure; plot(y, To, 'LineWidth',1.5);
xlabel('y [m]'); ylabel('T_o(y) [°C]');
title('Outlet Temperature Profile'); grid on;

% (b) Centerline temperature profile
[~, midRow] = min(abs(y-H/2));
Tc = Tfield(midRow,:);
figure; plot(x, Tc, 'LineWidth',1.5);
xlabel('x [m]'); ylabel('T_c(x) [°C]');
title('Centerline Temperature Profile'); grid on;

% (c) Velocity-weighted mean temperature
Tmean = zeros(1,nx);
for i = 1:nx
    Tmean(i) = trapz(y, ux .* Tfield(:,i)') / trapz(y, ux);
end
figure; plot(x,Tmean,'LineWidth',1.5);
xlabel('x [m]'); ylabel('T_{mean}(x) [°C]');
title('Velocity-weighted Mean Temperature'); grid on;

% (d) Entrance length xe (Tc reaches 90% of Twall)
target = Tin + 0.9*(Twall - Tin);
[~, idx_e] = min(abs(Tc - target));
xe = x(idx_e);
fprintf('Entrance length xe = %.3f m\n', xe);

%% Problem 14: SOR
omega_vals = [1, 1.5];
tol = 1e-5;
maxIter = 5000;

N = nx * ny;

for w = 1:length(omega_vals)
    omega = omega_vals(w);

    [T_sor, resHist, errHist, iter] = sor_solver(A, b, T, omega, tol, maxIter);

    figure;
    semilogy(resHist, 'r', 'LineWidth', 1.5); hold on;
    semilogy(errHist, 'b', 'LineWidth', 1.5);
    xlabel('Iteration'); ylabel('Normalized value');
    legend('Residual','Relative Error');
    title(sprintf('SOR Convergence (\\omega = %.2f, iter = %d)', omega, iter));
    grid on;
end

%% Problem 15: Local Nusselt number Nu_T(x) along the lower wall

NuT = compute_nusselt(Tfield, Twall, k, H, dy, ux);

% Plot
figure;
semilogx(x, NuT, 'LineWidth', 1.5); hold on;
yline(7.54, 'r--', 'LineWidth', 1.5, 'DisplayName','Asymptotic Nu_T = 7.54');
xlabel('x [m]');
ylabel('Nu_T(x)');
title('Local Nusselt Number along Lower Wall');
legend('Nu_T(x)', 'Theoretical limit 7.54','Location','best');
grid on;

% Comment
fprintf('Average Nu_T near outlet = %.3f\n', mean(NuT(end-5:end)));
fprintf(['Expected theoretical limit = 7.54\n', ...
         'Any sharp drop or oscillation near outlet likely comes from the Neumann\n', ...
         'boundary (dT/dx = 0), which reduces temperature gradients artificially.\n']);

%% Problem 16: Finer mesh

% Mesh definitions
meshes = [50, 5;
          100, 11;
          200, 21;
          400, 41]; % [nx, ny] rows

% Preallocate storage
To_all = cell(size(meshes,1),1);
Tc_all = cell(size(meshes,1),1);
Tmean_all = cell(size(meshes,1),1);
xe_all = zeros(size(meshes,1),1);
Nu_all = cell(size(meshes,1),1);
x_all = cell(size(meshes,1),1);
y_all = cell(size(meshes,1),1);

% Loop over meshes
for m = 1:size(meshes,1)
    nx = meshes(m,1);
    ny = meshes(m,2);

    % Build matrix and velocity
    [A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, "UD");

    % Solve linear system
    T = A \ b;

    % Reshape to 2D
    Tfield = reshape(T, [nx, ny])';

    % Store x, y
    x_all{m} = x;
    y_all{m} = y;

    % Outlet temperature
    To_all{m} = Tfield(:,end);

    % Centerline temperature
    [~, midRow] = min(abs(y-H/2));
    Tc_all{m} = Tfield(midRow,:);

    % Velocity-weighted mean temperature
    Tmean = zeros(1,nx);
    for i = 1:nx
        Tmean(i) = trapz(y, ux .* Tfield(:,i)') / trapz(y, ux);
    end
    Tmean_all{m} = Tmean;

    % Entrance length xe (centerline reaches 90% of Twall)
    target = Tin + 0.9*(Twall-Tin);
    [~, idx_e] = min(abs(Tc_all{m} - target));
    xe_all(m) = x(idx_e);

    % Local Nusselt number at lower wall
    Nu_all{m} = compute_nusselt(Tfield, Twall, k, H, y(2)-y(1), ux);
end

% Plot comparisons

% 1. Outlet temperature
figure; hold on; grid on;
for m = 1:length(To_all)
    plot(y_all{m}, To_all{m}, 'LineWidth', 1.5);
end
xlabel('y [m]'); ylabel('T_o(y) [°C]');
title('Outlet Temperature Profile Comparison');
legend('50x5','100x11','200x21','400x41','Location','best');

% 2. Centerline temperature
figure; hold on; grid on;
for m = 1:length(Tc_all)
    plot(x_all{m}, Tc_all{m}, 'LineWidth', 1.5);
end
xlabel('x [m]'); ylabel('T_c(x) [°C]');
title('Centerline Temperature Profile Comparison');
legend('50x5','100x11','200x21','400x41','Location','best');

% 3. Velocity-weighted mean temperature
figure; hold on; grid on;
for m = 1:length(Tmean_all)
    plot(x_all{m}, Tmean_all{m}, 'LineWidth', 1.5);
end
xlabel('x [m]'); ylabel('T_{mean}(x) [°C]');
title('Velocity-weighted Mean Temperature Comparison');
legend('50x5','100x11','200x21','400x41','Location','best');

% 4. Nusselt number at lower wall
figure; hold on; grid on;
for m = 1:length(Nu_all)
    semilogx(x_all{m}, Nu_all{m}, 'LineWidth', 1.5);
end
xlabel('x [m]'); ylabel('Nu_T(x)');
title('Local Nusselt Number Comparison');
legend('50x5','100x11','200x21','400x41','Location','best');

% Print entrance lengths
for m = 1:length(xe_all)
    fprintf('Mesh %dx%d: entrance length xe = %.3f m\n', meshes(m,1), meshes(m,2), xe_all(m));
end

%% Problem 17:
grids = [50 5; 100 11; 200 21; 400 41];
schemes = {'UD','QUICK'};

xe_all = zeros(length(grids), length(schemes));

for s = 1:length(schemes)
    scheme = schemes{s};
    
    for g = 1:size(grids,1)
        nx = grids(g,1);
        ny = grids(g,2);

        % Build matrix
        [A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, scheme);

        % Solve
        T = A\b;
        Tfield = reshape(T, [nx, ny])';

        % Centerline temperature
        [~, midRow] = min(abs(y-H/2));
        Tc = Tfield(midRow,:);

        % Compute xe
        target = Tin + 0.9*(Twall - Tin);
        [~, idx_e] = min(abs(Tc - target));
        xe_all(g,s) = x(idx_e);
    end
end

% Plot xe comparison
figure;
plot(grids(:,1), xe_all(:,1), 'o-', 'LineWidth',1.5); hold on;
plot(grids(:,1), xe_all(:,2), 's-', 'LineWidth',1.5);
xlabel('nx'); ylabel('Entrance length x_e [m]');
legend('UD','QUICK','Location','best');
title('Entrance length x_e for UD vs QUICK');
grid on;

% Plot relative variation with finest mesh
relVar = abs(xe_all - xe_all(end,:))./xe_all(end,:);

figure;
plot(grids(:,1), relVar(:,1), 'o-', 'LineWidth',1.5); hold on;
plot(grids(:,1), relVar(:,2), 's-', 'LineWidth',1.5);
xlabel('nx'); ylabel('Relative variation w.r.t finest mesh');
legend('UD','QUICK','Location','best');
title('Relative variation of x_e for different grids');
grid on;

%% Problem 18:

% Mesh sets
% 1) Fix nx = 400, vary ny
grids_y = [5, 11, 21];
% 2) Fix ny = 41, vary nx
grids_x = [100, 200, 400];

xe_y = zeros(length(grids_y), 1);
xe_x = zeros(length(grids_x), 1);

% Scheme selection
scheme = 'UD';

% Case 1: nx fixed, vary ny 
for g = 1:length(grids_y)
    nx = 400; ny = grids_y(g);
    [A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, scheme);
    T = A\b;
    Tfield = reshape(T, [nx, ny])';
    
    [~, midRow] = min(abs(y - H/2));
    Tc = Tfield(midRow,:);
    
    % Find entrance length (90% of Twall)
    target = Tin + 0.9*(Twall - Tin);
    [~, idx_e] = min(abs(Tc - target));
    xe_y(g) = x(idx_e);
end

% Case 2: ny fixed, vary nx
for g = 1:length(grids_x)
    nx = grids_x(g); ny = 41;
    [A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, scheme);
    T = A\b;
    Tfield = reshape(T, [nx, ny])';
    
    [~, midRow] = min(abs(y - H/2));
    Tc = Tfield(midRow,:);
    
    % Find entrance length (90% of Twall)
    target = Tin + 0.9*(Twall - Tin);
    [~, idx_e] = min(abs(Tc - target));
    xe_x(g) = x(idx_e);
end

% Grid spacings for plot
dx_x = L ./ (grids_x - 1);
dy_y = H ./ (grids_y - 1);

% Plot results

figure;
subplot(1,2,1)
plot(dy_y, xe_y, 'o-', 'LineWidth',1.5);
xlabel('\Delta y'); ylabel('x_e [m]');
title('Effect of vertical resolution (nx = 400)');
grid on;

subplot(1,2,2)
plot(dx_x, xe_x, 's-', 'LineWidth',1.5);
xlabel('\Delta x'); ylabel('x_e [m]');
title('Effect of streamwise resolution (ny = 41)');
grid on;

sgtitle('Problem 18: Effect of anisotropic grid refinement on entrance length x_e');

% Comments
fprintf('\n--- Problem 18 Summary ---\n');
fprintf('As dy decreases (more vertical cells), x_e converges faster.\n');
fprintf('As dx decreases (more horizontal cells), improvements are smaller because flow is mostly streamwise.\n');
fprintf('Thus, vertical refinement (better wall resolution) can improve accuracy more efficiently.\n');

%% Problem 19: Effect of large Peclet numbers (Pe = 50 and Pe = 100)

% Mesh and scheme
nx = 100; ny = 11;
scheme = 'UD';

Pe_list = [50, 100];

figure('Units','normalized','Position',[0.05 0.05 0.9 0.7]);

for p = 1:length(Pe_list)
    Pe = Pe_list(p);

    % --- Build matrix and velocity profile ---
    [A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, scheme);

    % --- Solve steady-state system ---
    T = A\b;
    Tfield = reshape(T, [nx, ny])';

    % --- Compute local cell Peclet number ---
    dx = L/(nx-1);
    Pecell = abs(rho .* ux * dx / Gamma);
    maxPec = max(Pecell);

    % --- Plot temperature field ---
    subplot(2,2,p*2-1);
    [X, Y] = meshgrid(x, y);
    contourf(X, Y, Tfield, 30, 'LineColor', 'none');
    colorbar;
    xlabel('x [m]'); ylabel('y [m]');
    title(sprintf('T(x,y)  —  Pe = %d', Pe));
    axis tight;

    % --- Plot centerline profile ---
    subplot(2,2,p*2);
    [~, midRow] = min(abs(y - H/2));
    Tc = Tfield(midRow,:);
    plot(x, Tc, 'LineWidth', 1.5);
    xlabel('x [m]'); ylabel('T_c(x) [°C]');
    title(sprintf('Centerline temperature — Pe = %d (max local Pe = %.2f)', Pe, maxPec));
    grid on;

    % --- Print diagnostics ---
    fprintf('Pe = %d | Mesh: %dx%d | Max local Peclet = %.2f\n', Pe, nx, ny, maxPec);
end

sgtitle('Problem 19: Temperature field and centerline temperature at large Pe');

% --- Discussion (Command Window) ---
fprintf('\n--- Problem 19 Discussion ---\n');
fprintf(['As Pe increases, convection dominates diffusion, causing thinner thermal boundary layers.\n' ...
         'These steep gradients make the system more difficult to solve numerically.\n' ...
         'At high Pe, standard schemes may show oscillations or numerical instability unless upwinding\n' ...
         'or finer meshes are used. The problem becomes convection-dominated, and resolving boundary layers\n' ...
         'requires either higher-order stabilized schemes (e.g., QUICK, TVD) or grid refinement near the walls.\n']);

%% Problem 20: Neumann boundary condition (q_wall = 10 W/m^2)

% --- Physical and grid parameters ---
rho = 1; cp = 10; k = 0.12;
Gamma = k / cp;
H = 1; L = 10;
Pe = 16.5;
Tin = 50;
qwall = 10; % W/m^2

nx = 100; ny = 11;
scheme = "UD";

% --- Build matrix as before ---
[A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, NaN, Pe, scheme);

% --- Apply Neumann boundary conditions manually ---
dy = H / (ny - 1);
N = nx * ny;

% Loop over all bottom and top boundary nodes
for i = 1:nx
    % Bottom wall node (j=1)
    n_bot = (i-1)*ny + 1;
    n_nb  = n_bot + 1; % neighbor above
    A(n_bot,:) = 0; 
    A(n_bot, n_bot) = 1;
    A(n_bot, n_nb) = -1;
    b(n_bot) = qwall * dy / k; % T1 - T2 = qwall*dy/k

    % Top wall node (j=ny)
    n_top = (i-1)*ny + ny;
    n_nb  = n_top - 1; % neighbor below
    A(n_top,:) = 0;
    A(n_top, n_top) = 1;
    A(n_top, n_nb) = -1;
    b(n_top) = -qwall * dy / k; % Tny - Tny-1 = -qwall*dy/k
end

% Keep inlet (x=0) as Dirichlet
for j = 1:ny
    n = j;
    A(n,:) = 0;
    A(n,n) = 1;
    b(n) = Tin;
end

% --- Solve ---
T = A \ b;
Tfield = reshape(T, [nx, ny])';

% --- Visual check ---
figure;
contourf(x, y, Tfield, 30, 'LineColor','none');
colorbar;
xlabel('x [m]'); ylabel('y [m]');
title('Temperature Field T(x,y) with Neumann Wall BC (q_{wall}=10 W/m^2)');

% --- Check flux consistency ---
dy = H / (ny - 1);
q_bottom_num = -k * (Tfield(2,:) - Tfield(1,:)) / dy;
fprintf('Average numerical bottom wall flux = %.3f W/m² (target = %.2f)\n', ...
        mean(q_bottom_num), qwall);

% --- Compute and plot Nu_q(x) ---
Nuq = (2*H/k) .* q_bottom_num ./ (mean(Tfield) - Tin);

figure;
plot(x, Nuq, 'LineWidth', 1.5);
xlabel('x [m]');
ylabel('Nu_q(x)');
title('Local Nusselt number Nu_q(x) with Neumann wall condition');
grid on;

fprintf(['\n--- Problem 20 Summary ---\n' ...
         'The Neumann BCs replace fixed wall temperatures by fixed heat flux q_wall.\n' ...
         'The resulting temperature field shows a linear near-wall gradient consistent with q_wall.\n' ...
         'Numerical wall flux verification confirms correct boundary implementation.\n']);

%% Problem 21 & 22: Global energy balance (21) and local heating on a wall (22)
% Adds two new sections. Assumes build_matrix(...) exists and returns A,b,x,y,ux
% Uses same variables / conventions as the main script (units per unit depth).

%% ---------- Problem 21: Global energy balance for uniform wall flux ----------
% Uniform wall flux case (reuse Problem 20 style). We'll compute heat through:
%  - Inlet (convection): Q_in = int_0^H rho*cp*ux(y)*T_in dy
%  - Outlet (convection): Q_out = int_0^H rho*cp*ux(y)*T(L,y) dy
%  - Bottom wall flux: Qb = int_0^L q_bottom(x) dx  (positive into fluid)
%  - Top wall flux: Qt = int_0^L q_top(x) dx
% Global balance: Q_in + Qb + Qt - Q_out  ≈ 0

% Parameters for Problem 21
nx = 100; ny = 21;          % moderate mesh for diagnostics
Pe = 16.5;
Tin = 50;
qwall_uniform = 10;        % W/m^2 (positive into the solid? here we treat positive into fluid)
scheme = "UD";

% Build system (we will overwrite wall equations to impose Neumann)
[A, b, x, y, ux] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, scheme);

dx = L / (nx - 1);
dy = H / (ny - 1);
idx = @(i,j) (j-1)*nx + i;

% Overwrite bottom & top rows to impose uniform Neumann qwall_uniform
% Bottom (j=1): T(1) - T(2) = q*dy/k  => A(row, row) = 1; A(row, idx(i,2)) = -1; b = q*dy/k
% Top (j=ny): T(ny) - T(ny-1) = q*dy/k
q_bottom_profile = qwall_uniform * ones(1,nx);
q_top_profile    = qwall_uniform * ones(1,nx);

% Apply Neumann on bottom and top
for i = 1:nx
    % bottom
    n_bot = idx(i,1);
    n_bot_nb = idx(i,2);
    A(n_bot,:) = 0;
    A(n_bot,n_bot) = 1;
    A(n_bot,n_bot_nb) = -1;
    b(n_bot) = q_bottom_profile(i)*dy / k;

    % top
    n_top = idx(i,ny);
    n_top_nb = idx(i,ny-1);
    A(n_top,:) = 0;
    A(n_top,n_top) = 1;
    A(n_top,n_top_nb) = -1;
    b(n_top) = q_top_profile(i)*dy / k;
end

% Re-enforce inlet Dirichlet (in case build_matrix set walls previously)
for j = 1:ny
    n_in = idx(1,j);
    A(n_in,:) = 0;
    A(n_in,n_in) = 1;
    b(n_in) = Tin;
end

% Outlet remains Neumann as before (build_matrix handled it)

% Solve
T = A \ b;
Tfield = reshape(T, [nx, ny])';  % ny x nx

% Compute fluxes and global balance
% Inlet convective heat flow (positive into domain)
Q_in = trapz(y, rho * cp .* ux .* Tin); % Tin constant at inlet

% Outlet convective heat flow
To_num = Tfield(:,end)'; % 1 x ny
Q_out = trapz(y, rho * cp .* ux .* To_num);

% Bottom numeric flux (forward difference from wall into fluid)
q_bottom_num = -k * (Tfield(2,:) - Tfield(1,:)) / dy;  % 1 x nx, positive into fluid
Qb_total = trapz(x, q_bottom_num);

% Top numeric flux (backward difference)
q_top_num = k * (Tfield(end,:) - Tfield(end-1,:)) / dy;  % 1 x nx
Qt_total = trapz(x, q_top_num);

% Global residual (should be ~0)
global_residual = Q_in + Qb_total + Qt_total - Q_out;
relative_residual = global_residual / max([abs(Q_in), abs(Q_out), abs(Qb_total)+abs(Qt_total), 1e-12]);

% Print diagnostics
fprintf('\n--- Problem 21: Global energy balance (uniform qwall = %.2f W/m^2) ---\n', qwall_uniform);
fprintf('Q_in  (convection at inlet)  = %.6f W per unit depth\n', Q_in);
fprintf('Q_out (convection at outlet) = %.6f W per unit depth\n', Q_out);
fprintf('Q_bottom (integrated numerical) = %.6f W per unit depth\n', Qb_total);
fprintf('Q_top    (integrated numerical) = %.6f W per unit depth\n', Qt_total);
fprintf('Global residual (Q_in + Qb + Qt - Q_out) = %.6e W per unit depth\n', global_residual);
fprintf('Relative residual = %.6e\n', relative_residual);

% Quick visual check
figure;
subplot(1,2,1);
contourf(x, y, Tfield, 30, 'LineColor','none'); colorbar;
xlabel('x'); ylabel('y'); title('T(x,y) with uniform wall flux (Problem 21)');

subplot(1,2,2);
plot(x, q_bottom_num, '-o'); hold on;
yline(qwall_uniform,'r--','Target q_{wall}');
xlabel('x'); ylabel('q_{bottom}(x) [W/m^2]');
title('Numerical bottom wall flux vs target'); grid on;

%% ---------- Problem 22: Local heating 2 <= x <= 5 on lower wall ----------
% Task: find qwall values (uniform over 2<=x<=5 region) that produce outlet
% velocity-weighted mean temperatures approx 60, 70, 80 degC.
% Approach: bisection on q_mag for each target. Walls are adiabatic elsewhere.

nx = 200; ny = 21;   % use moderately fine mesh for this study
Pe = 16.5;
Tin = 50;
scheme = "UD";
x_region = [2, 5];   % m, heating region on lower wall
targets = [60, 70, 80];   % desired outlet velocity-weighted mean temperatures (degC)
tolerance_T = 0.05;       % acceptable temperature tolerance [degC]
max_bisect_iter = 30;

% Precompute grid and helper
[A0, b0, xg, yg, uxg] = build_matrix(nx, ny, L, H, rho, Gamma, Tin, Twall, Pe, scheme);
dx = L/(nx-1); dy = H/(ny-1);
idx = @(i,j) (j-1)*nx + i;

% Determine indices of bottom nodes that fall into [2,5]
ix_start = find(xg >= x_region(1), 1, 'first');
ix_end   = find(xg <= x_region(2), 1, 'last');
if isempty(ix_start) || isempty(ix_end)
    error('Heating region indices not found (check grid and region bounds).');
end
heating_indices = ix_start:ix_end;

% Bisection function: for a given q_mag (W/m^2) applied (positive into fluid)
% build A,b with bottom Neumann profile: q(x)=q_mag for heating region, 0 elsewhere.
% top wall adiabatic (q=0). Return velocity-weighted outlet mean temperature.
function Tmean_out = outlet_mean_for_q(q_mag)
    % start from template with walls left as originally set by build_matrix
    A = A0; b = b0;
    % Overwrite bottom and top rows:
    for i = 1:nx
        n_bot = idx(i,1); n_bot_nb = idx(i,2);
        q_here = 0;
        if ismember(i, heating_indices)
            q_here = q_mag;
        end
        % bottom Neumann: T1 - T2 = q*dy/k
        A(n_bot,:) = 0;
        A(n_bot,n_bot) = 1;
        A(n_bot,n_bot_nb) = -1;
        b(n_bot) = q_here * dy / k;

        % top wall: adiabatic everywhere => q=0 => Tny - Tny-1 = 0
        n_top = idx(i,ny); n_top_nb = idx(i,ny-1);
        A(n_top,:) = 0;
        A(n_top,n_top) = 1;
        A(n_top,n_top_nb) = -1;
        b(n_top) = 0;
    end
    % Re-impose inlet Dirichlet
    for j = 1:ny
        n_in = idx(1,j);
        A(n_in,:) = 0;
        A(n_in,n_in) = 1;
        b(n_in) = Tin;
    end
    % Solve
    Tloc = A\b;
    Tfield_loc = reshape(Tloc, [nx, ny])';
    To_loc = Tfield_loc(:,end)'; % 1 x ny
    % velocity-weighted mean temperature at outlet
    Tmean_out = trapz(yg, uxg .* To_loc) / trapz(yg, uxg);
end

% Now perform bisection for each target
q_required = zeros(size(targets));
for tt = 1:length(targets)
    Ttarget = targets(tt);
    % initial bracket for q: q_low=0, q_high increase until outlet mean > target
    q_low = 0;
    q_high = 1e4; % large initial guess
    T_low = outlet_mean_for_q(q_low);
    T_high = outlet_mean_for_q(q_high);
    if T_high < Ttarget
        error('q_high too small, increase q_high.');
    end
    % bisection
    for iter = 1:max_bisect_iter
        q_mid = 0.5*(q_low + q_high);
        T_mid = outlet_mean_for_q(q_mid);
        if abs(T_mid - Ttarget) < tolerance_T
            break;
        end
        if T_mid < Ttarget
            q_low = q_mid;
        else
            q_high = q_mid;
        end
    end
    q_required(tt) = q_mid;
    fprintf('Target T_out = %d °C -> q_required = %.3f W/m^2 (iter=%d), achieved T_out = %.3f\n', ...
        Ttarget, q_mid, iter, T_mid);
end

% Display results and plot one example solution (for the middle target)
fprintf('\n--- Problem 22 Results ---\n');
for tt = 1:length(targets)
    fprintf('Target %d°C -> q_required = %.3f W/m^2\n', targets(tt), q_required(tt));
end

% Plot final case Tfield for the last computed q (choose middle target)
q_plot = q_required(2);
Tmean_out_plot = outlet_mean_for_q(q_plot); % also computes solution internally
% Rebuild and get final Tfield for plotting
A = A0; b = b0;
for i = 1:nx
    n_bot = idx(i,1); n_bot_nb = idx(i,2);
    q_here = 0;
    if ismember(i, heating_indices)
        q_here = q_plot;
    end
    A(n_bot,:) = 0; A(n_bot,n_bot) = 1; A(n_bot,n_bot_nb) = -1; b(n_bot) = q_here*dy/k;
    n_top = idx(i,ny); n_top_nb = idx(i,ny-1);
    A(n_top,:) = 0; A(n_top,n_top) = 1; A(n_top,n_top_nb) = -1; b(n_top) = 0;
end
for j = 1:ny
    n_in = idx(1,j); A(n_in,:) = 0; A(n_in,n_in) = 1; b(n_in) = Tin;
end
Tfinal = A\b;
Tfield_final = reshape(Tfinal, [nx, ny])';
figure;
contourf(xg, yg, Tfield_final, 30,'LineColor','none'); colorbar;
xlabel('x [m]'); ylabel('y [m]');
title(sprintf('Temperature field, local heating q=%.2f W/m^2 in x∈[%.1f,%.1f], outlet mean = %.2f°C', ...
    q_plot, x_region(1), x_region(2), Tmean_out_plot));
% Also plot bottom flux profile (numerical)
q_bottom_final = -k*(Tfield_final(2,:) - Tfield_final(1,:))/dy;
figure;
plot(xg, q_bottom_final, '-o'); hold on;
plot(xg(heating_indices), q_bottom_final(heating_indices), 'r.', 'MarkerSize',12);
xlabel('x [m]'); ylabel('q_{bottom}(x) [W/m^2]'); grid on;
title('Numerical bottom wall flux (red markers indicate heating region)');

% Short comment for report:
fprintf(['\nProblem 22 comment:\n- The required heating flux q (W/m^2) found by bisection is printed above\n' ...
         '- The resulting outlet velocity-weighted mean temperature matches the target within tolerance.\n' ...
         '- Note required q values depend on mesh resolution and on neglecting axial conduction in inlet/outlet discretization.\n']);
